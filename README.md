# Yangon
A high-performance, stack-allocated string type for Rust with fixed capacity and zero heap allocations.

**Yangon** is a stack-allocated alternative to `String`. Using fixed-capacity storage and const generics, it eliminates heap allocations for performance-critical applications while maintaining a familiar `String`-like API. **Highlights:** * ~25x faster than `String` for `push_str` operations * Zero heap allocations â€” all data stored on the stack * Configurable capacity via const generics * Full UTF-8 validation and support Add Yangon to your `Cargo.toml`: `[dependencies] yangon = "0.0.2"`
`use yangon::{Yangon, yangon}; let mut s = Yangon::new(); s.push_str("Hello, ").unwrap(); s.push_str("Yangon!").unwrap(); println!("{}", s); let s = yangon!("Hello, World!"); let mut small: Yangon<64> = Yangon::with_capacity(); small.push_str("Small buffer").unwrap();`
Key Features. Stack Allocation: No heap allocations - all string data lives on the stack. Predictable memory usage - capacity known at compile time. Default 10KB capacity when using `Yangon::new()` or `Yangon::from()`. Configurable via const generics - `Yangon<N>` where `N` is byte capacity. String-Like API: Yangon provides familiar methods similar to `String`: `let mut s = yangon!("Hello"); s.push_str(" World").unwrap(); s.push('!').unwrap(); s.insert(5, ','); s.remove(5); s.pop(); s.clear(); s.truncate(5); assert_eq!(s.len(), 5); assert!(!s.is_empty()); assert_eq!(s.as_str(), "Hello");`
Advanced Pattern Matching: Yangon's `replace` function supports multiple pattern types with turbo fish syntax: `let s = yangon!("Hello World"); let s1 = s.replace::<&str, 0>("World", "Yangon"); let s2 = s.replace::<char, 0>('o', "0"); let s3 = s.replace::<_, 2>(&['H', 'W'], "X"); let s4 = s.replace::<fn(char) -> bool, 0>(|c| c.is_whitespace(), "");`
UTF-8 Handling: Full UTF-8 support with validation: `use yangon::Yangon; let s = Yangon::from_utf8(vec![72, 101, 108, 108, 111]).unwrap(); let s = unsafe { Yangon::from_utf8_unchecked(vec![72, 101, 108, 108, 111]) }; let bytes = vec![0xFF, 0xFE, 72, 105]; let s = Yangon::from_utf8_lossy(&bytes);`
Iteration and Collection: `use yangon::Yangon; let chars = vec!['H', 'e', 'l', 'l', 'o']; let s: Yangon = chars.into_iter().collect(); let mut s = yangon!("Hello123World"); s.retain(|c| c.is_alphabetic()); assert_eq!(s, "HelloWorld");`
Additional Operations: `let mut s = yangon!("  Hello World  "); assert_eq!(s.trim(), "Hello World"); let s2 = s.split_off(7); s.replace_range(0..5, "Hi"); let bytes: Vec<u8> = s.into_bytes(); let string: String = s.to_string();`
Use Cases: Yangon is ideal for: Performance-critical code where heap allocation overhead is unacceptable. Embedded systems with limited or no heap allocation. Network protocols requiring fixed-size string buffers. Data transfer/storage with known maximum string lengths. Real-time applications requiring predictable performance. API Conversion Reference: `| String Method | Yangon Equivalent | Returns | | :-------------- | :------------------ | :------ | | String::new() | Yangon::new() | Yangon | | String::from(s) | Yangon::from(s) | Yangon | | s.push_str(s) | s.push_str(s) | Result<(), yError> | | s.push(c) | s.push(c) | Result<(), yError> | | s.as_str() | s.as_str() | &str | | String::from_utf8(v) | Yangon::from_utf8(v) | Result<Yangon, yError> | | String::from_utf8_lossy(v) | Yangon::from_utf8_lossy(v) | yCow<Yangon> |`
Traits Implemented: `Display` - Format for printing. `Debug` - Debug formatting. `Write` - Format writing support. `Deref<Target = str>` - Automatic coercion to `&str`. `AsRef<str>` - Borrow as string slice. `PartialEq<&str>` - Compare with string slices. `FromIterator<char>` - Build from character iterator. `Clone` - Deep copy support.
Error Handling: `use yangon::yError; match s.push_str("test") { Ok(()) => println!("Success"), Err(yError::CapacityOverflow) => println!("Buffer full!"), Err(yError::FromUtf8Error) => println!("Invalid UTF-8"), }`
Macro Usage: The `yangon!` macro provides convenient initialization: `let empty = yangon!(); let s = yangon!("Hello, World!");` Note: Only accepts 0 or 1 string literal.
Documentation: Full API documentation is coming soon to [docs.rs](https://docs.rs).
License: This project is licensed under the MIT License - see the `LICENSE` file for details.
Contributing: This is a stable, production-ready project. While it's not actively seeking contributors, bug reports and suggestions are welcome via GitHub issues.
About the Name: Yangon is named after the capital city of Myanmar. The name reflects the project's foundation: solid, reliable, and built for real-world use. Note: Yangon prioritizes performance over flexibility. Understand your string size requirements before choosing Yangon over String. When used appropriately, it provides significant performance benefits with zero heap allocation overhead.
